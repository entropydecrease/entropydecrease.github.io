<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on Entropy Decrease</title>
    <link>https://entropydecrease.github.io/tags/git/</link>
    <description>Recent content in Git on Entropy Decrease</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 25 Mar 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://entropydecrease.github.io/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>git tips</title>
      <link>https://entropydecrease.github.io/posts/git_tips/</link>
      <pubDate>Wed, 25 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://entropydecrease.github.io/posts/git_tips/</guid>
      <description>&lt;h1 id=&#34;从现有仓库克隆&#34;&gt;从现有仓库克隆&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/grit.git&#xA;&#xA;$ git clone git://github.com/schacon/grit.git mygrit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;gitignore&#34;&gt;.gitignore&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cat ~/.gitignore&#xA;*~&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;撤消操作&#34;&gt;撤消操作&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;* 修改最后一次提交&#xA;&#xA;  $ git commit --amend&#xA;&#xA;  如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：&#xA;&#xA;  $ git commit -m &#39;initial commit&#39;  &#xA;  $ git add forgotten_file  &#xA;  $ git commit --amend  &#xA;&#xA;* 取消已经暂存的文件 - 其实，git status 的命令输出已经告诉了我们该怎么做&#xA;&#xA;  $ git add .  &#xA;  $ git status  &#xA;  On branch master  &#xA;  Changes to be committed:  &#xA;  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)  &#xA;&#xA;       modified:   README.txt  &#xA;   modified:   benchmarks.rb    &#xA;  $ git reset HEAD benchmarks.rb  &#xA;  Unstaged changes after reset:   &#xA;  M       benchmarks.rb   &#xA;&#xA;* 取消对文件的修改 - git status 同样提示了具体的撤消方法&#xA;&#xA;  Changes not staged for commit:  &#xA;  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)   &#xA;  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)  &#xA;&#xA;      modified:   benchmarks.rb  &#xA;&#xA; $ git checkout -- benchmarks.rb  &#xA; $ git status  &#xA; On branch master  &#xA; Changes to be committed:  &#xA; (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)  &#xA;&#xA;     modified:   README.txt   &#xA;&#xA; 任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 --amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;远程仓库的使用&#34;&gt;远程仓库的使用&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;* 查看当前的远程库&#xA;&#xA;  $ git remote  &#xA;  $ git remote -v  &#xA;&#xA;* 添加远程仓库 - git remote add [shortname] [url]&#xA;&#xA;  $ git remote  &#xA;  origin  &#xA;  $ git remote add pb git://github.com/paulboone/ticgit.git  &#xA;  $ git remote -v  &#xA;  origin  git://github.com/schacon/ticgit.git  &#xA;  pb  git://github.com/paulboone/ticgit.git  &#xA;&#xA;  现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb：&#xA;&#xA;  $ git fetch pb  &#xA;  remote: Counting objects: 58, done.  &#xA;  remote: Compressing objects: 100% (41/41), done.  &#xA;  remote: Total 44 (delta 24), reused 1 (delta 0)  &#xA;  Unpacking objects: 100% (44/44), done.  &#xA;  From git://github.com/paulboone/ticgit  &#xA;   * [new branch]      master     -&amp;gt; pb/master  &#xA;   * [new branch]      ticgit     -&amp;gt; pb/ticgit  &#xA;&#xA;* 从远程仓库抓取数据&#xA;&#xA;  $ git fetch [remote-name]&#xA;&#xA;  如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。&#xA;&#xA;  如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。&#xA;&#xA;* 推送数据到远程仓库 - git push [remote-name] [branch-name]&#xA;&#xA;  如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：&#xA;&#xA;  $ git push origin master  &#xA;&#xA;  只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送&#xA;&#xA;* 查看远程仓库信息 - git remote show [remote-name]&#xA;&#xA;  $ git remote show origin  &#xA;  * remote origin  &#xA;    URL: git://github.com/schacon/ticgit.git  &#xA;    Remote branch merged with &#39;git pull&#39; while on branch master  &#xA;     master  &#xA;    Tracked remote branches  &#xA;     master  &#xA;     ticgit  &#xA;&#xA;* 远程仓库的删除和重命名 - git remote rename&#xA;&#xA;  比如想把 pb 改成 paul，可以这么运行：&#xA;&#xA;  $ git remote rename pb paul    &#xA;  $ git remote    &#xA;  origin    &#xA;  paul  &#xA;&#xA;  注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。&#xA;  &#xA;  碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：&#xA;  &#xA;  $ git remote rm paul  &#xA;  $ git remote  &#xA;  origin  &#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
